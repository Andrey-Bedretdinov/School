# Через генератор списка и функцию split делим нашу строку ввода по пробелу и
# и перебирая список, созданный этой функцией задаем для каждого целочисленный
# тип (input по умолчанию задает тип строки), и записываем в свои переменные
# N и k, где: N - кол-во лампочек, k - кол-во инверсий

N, k = [int(i) for i in input().split()]

# Здесь через функцию list создаем массив, элементы которого при помощи map
# будут целочисленными (по такому же принципу, как и выше, делим нашу строку по
# пробелу)
not_sorted_p = list(map(int, input().split()))

# Создадим сразу пустой массив, где поместим уже обработанный массив делителей
# инверсий (исключим двойные отрицания)
p = []

p_index = []

# Данным перебором мы исключим из нашего ряда кратное количество делителей для
# инверсий, поскольку при таком значении все лампочки останутся в исходном
# положении
for i in not_sorted_p:
    # Если количество наших элементов в ряде не кратное, следовательно лампы
    # по итогу все окажутся инвертированы (в обратном случае эффект
    # компенсируется, так как происходит двойное отрицание: not(not(p_index)) = p_index)
    if not_sorted_p.count(i) % 2 == 1:
        p.append(i)

# Сортируем наш обработанный массив
p.sort()

# Делаем схожую проверку, что и выше, но для единиц, так как тогда все лампы
# будут инвертированы, а при большом их количестве, инвертация займет много
# времени (если количество единиц будет делится нацело на 2 - значит они
# просто не учитываются, иначе мы задаем bool-значение переменной, от которой
# в конце будет зависеть - либо выводим прямой ответ, либо разницу кол-ва
# лампочек и нашего счетчика, она же инверсия ответа)
if p.count(1) % 2 == 1:
    all_inversion = True
    p = p[p.count(1):]
else:
    all_inversion = False

# Задаем промежуточную переменную-массив путем list (иначе создадим просто
# адрес на имеющуюся и обе наши переменные будут изменяться параллельно)
p_buffer = list(p)

# Основной цикл прохода по делителям и записи в наш массив p_index тех
# значений-кратных, которые не делятся нацело на 2
while k != 0:

    k = len(p)

    for i in range(len(p)):
        if p_buffer[i] > N:
            k -= 1
        elif p_index.count(p_buffer[i]) == 0:
            p_index.append(p_buffer[i])
        else:
            p_index.remove(p_buffer[i])

        p_buffer[i] += p[i]

# Считаем кол-во наших включенных ламп
n = len(p_index)

# Если в массиве делителей была единица - ответом будет разница нашего кол-ва
# лампочек и кол-ва включенных, так как так мы проведем финальную инверсию
# абсолюнто всех лампочек
if all_inversion:
    print(N - n)

# Если единиц в массиве не было
else:
    print(n)